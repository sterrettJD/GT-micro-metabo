---
title: "Microbe-metabolite regression analysis"
author: "John Sterrett"
date: '2022-07-14'
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

pacman::p_load(tidyverse,
               lme4, lmerTest,
               qiime2R,
               data.table,
               foreach,
               parallel,
               doSNOW,
               ggrepel,
               HLMdiag)

'%ni%' <- Negate('%in%')

setwd("/Users/johnsterrett/Research-Projects/Reisdorph/GT-micro-metabo/analysis")


```

# Load data

```{r load_data, echo=F}
# read in genus level table
genus <- read_qza("../microbiome/L6-collapsed-table.qza")$data %>% as.data.frame()
genus_names <- row.names(genus)

# convert to relative abundance
genus <- sapply(genus,
                prop.table) * 100
genus <- genus %>% as.data.frame(row.names = genus_names)

# check that all colsums are 100
print(
    "Checking that all microbiome columns add to 100% (relative abundance)... All unique column sums are below (they should be 100): "
)
unique(colSums(genus))

genus <- t(genus) %>% as.data.frame()


# read in metadata
metadata <- fread("../metadata/mapping.tsv", sep = "\t")
rownames(metadata) <- metadata$`MetaboSampleID`

# read in metabolites
aqueous <- fread("../metabolome/raw_aqueous.tsv",
                 sep="\t", header = T) %>% as.data.frame()
aqueous <- aqueous %>% remove_rownames() %>% column_to_rownames(var="V1")

aqueous <- aqueous[rownames(aqueous) %ni% c("Compound Name", "Retention Time",
                                          "Measured Retention Time", "Product Mass",
                                         "QualifierMass", "CASNumber",
                                         "CompoundType", "ISTDCompoundName", 
                                         "Mass Column"),]
aqueous <- mutate_all(aqueous, function(x) as.numeric(as.character(x)))


# read in lipids
lipids <- fread("../metabolome/raw_lipid.tsv",
                sep="\t",
                header = T)

rownames(lipids) <- lipids$V1
lipids <- lipids %>% remove_rownames() %>% column_to_rownames(var="V1")

lipids <- lipids[rownames(lipids) %ni% c("Compound Name", "Retention Time",
                                          "Measured Retention Time", "Product Mass",
                                         "QualifierMass", "CASNumber",
                                         "CompoundType", "ISTDCompoundName", 
                                         "Mass Column"),]
lipids <- mutate_all(lipids, function(x) as.numeric(as.character(x)))

# map genus sample ids to metabolomics sample ids
new_genus_sample_ids <- c()
for (x in row.names(genus)){
    sampleid <- metadata[metadata$`#SampleID`==x, "MetaboSampleID"][[1,1]]
    new_genus_sample_ids <- c(new_genus_sample_ids, sampleid)
}

# for (i in 1:length(new_genus_sample_ids)){
#    print(paste0("Mapping ", rownames(genus)[i], 
#                 " to ", new_genus_sample_ids[i]))
#}

rownames(genus) <- new_genus_sample_ids

# sort dataframes
 genus <- genus[order(as.numeric(rownames(genus))),,drop=FALSE]
 metadata <- metadata[order(as.numeric(rownames(metadata))),,drop=FALSE]
 aqueous <- aqueous[order(as.numeric(rownames(aqueous))),,drop=FALSE]
 lipids <- lipids[order(as.numeric(rownames(lipids))),,drop=FALSE]
```

# Transform data
```{r transform_data, echo=F}
# hist before transformation
print("Histograms before transformation")
hist(genus[, 1:4])

# arcsinh transform microbiome data
genus <- genus %>% mutate_all(function(x) log(x + sqrt(x^2 + 1)))

# hist after transformation
print("Histograms after arcsinh transformation")
hist(genus[, 1:4])



```



# Assess sparsity
```{r sparsity, echo=F}
# microbiome
print("Microbiome feature sparsity")
feature_sparsity <- genus %>% sapply(function(x) coop::sparsity(as.matrix(x)))
hist(feature_sparsity, breaks=10)

# aqueous
print("Aqueous metabolome feature sparsity")
feature_sparsity <- aqueous %>% sapply(function(x) coop::sparsity(as.matrix(x)))
hist(feature_sparsity, breaks=50)
print("Unique sparsity values are: ")
unique(feature_sparsity)

# lipids
print("Lipidome feature sparsity")
feature_sparsity <- lipids %>% sapply(function(x) coop::sparsity(as.matrix(x)))
hist(feature_sparsity, breaks=50)
print("Unique sparsity values are: ")
unique(feature_sparsity)
```


# Regressions

1. Scaled each metabolite to have a mean 0 and sd 1, so regression coefficients are comparable
2. Ran regressions on each microbe-metabolite combination (metabolite ~ microbe)
3. Extracted the regression coefficient, p value, and maximum influence of any sample on the regression

```{r basic_regression, results='hide', echo=F}
all_df <- cbind(genus, aqueous, lipids)
metabo_df <- cbind(aqueous, lipids)

lm_df <- all_df %>% janitor::clean_names()
feat_name_mapped <- data.frame(new=names(lm_df), old=names(all_df))

# Janet Seibert's suggested dffits threshold
dffits_thresh <- 4

# create function to parallelize
run_lm <- function(i, j){
    microbe <- feat_name_mapped[feat_name_mapped$old==genus_names[i], 
                                "new"]
    metabolite <- feat_name_mapped[feat_name_mapped$old==names(metabo_df)[j], 
                                   "new"]
    # scale the metabolite so beta is interpretable
    curr_lm_df <- lm_df[, c(microbe, metabolite)]
    curr_lm_df[, metabolite] <- scale(curr_lm_df[, metabolite])
    
    # create formula
    formula <- paste(metabolite, "~", microbe)
    
    # run model
    mod <- lm(formula, curr_lm_df)
    
    # extract p and beta
    p <- coef(summary(mod))[microbe,"Pr(>|t|)"]
    my_beta <- coef(summary(mod))[microbe,"Estimate"]
    
    # calculate maximum influence of any point
    dffits_df <- as.data.frame(dffits(mod))
    max_influence <- max(abs(dffits_df))
    
    # add new results to df
    new_results <- list(microbe, metabolite, p, my_beta, max_influence)
    return(new_results)
}

#setup parallel backend to use many processors
cores <- detectCores()
cl <- makeCluster(cores[1]-1) #not to overload your computer
doParallel::registerDoParallel(cl)

registerDoSNOW(cl) # not sure what this is
iterations_i <- ncol(genus)
iterations_j <- ncol(metabo_df)
pb <- txtProgressBar(max = iterations_i*iterations_j, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)


results_parallel <- data.frame(matrix(nrow=ncol(genus)*ncol(metabo_df), 
                                      ncol=5))
names(results_parallel) <- c("microbe", "metabolite", "p", "beta", "max_influence") 

ptm <- proc.time()
y <- foreach(i=1:iterations_i, 
             .combine=cbind, 
             .options.snow = opts) %:%
    foreach(j=1:iterations_j, 
            .combine=cbind, 
            .options.snow = opts) %dopar% {
                progress(i)
                run_lm(i,j)
            }

print(paste0((proc.time() - ptm)[["elapsed"]]/60, " minutes"))

#stop cluster
stopCluster(cl)
```

# Assessing regression results

First histogram shows the distribution of regression coefficients.
Second histogram shows the distribution of maximum influence of any point for each regression. Then, the 50th, 90th, 95th, and 99th percentiles of the maximum influence values for each regression are printed. We will remove any regressions with maximum influence > 4.
```{r process_and_summarize_results, echo=F}

results_parallel$microbe <- unlist(y[1,])
results_parallel$metabolite <- unlist(y[2,])
results_parallel$p <- unlist(y[3,])
results_parallel$beta <- unlist(y[4,])
results_parallel$max_influence <- unlist(y[5,])


hist(results_parallel$beta, breaks=100)

hist(results_parallel$max_influence, breaks=20)

quantile(results_parallel$max_influence, c(0.5, 0.9, 0.95, 0.99), na.rm=T)

summary(results_parallel)

```


# Assess significant regressions

p values were false discovery rate (fdr) corrected via a benjamini-hochberg correction. A volcano plot shows beta (the regression coefficient) along the x axis and -log10(uncorrected p value) on the y axis.

```{r lm_results, echo=F, warning=F}
results_dffilt <- results_parallel %>% 
    filter(max_influence < 4)

results_dffilt$fdr_p <- results_dffilt$p %>% 
    p.adjust("BH")


results_dffilt$sig <- ifelse(test = results_dffilt$p > 0.05, # check baseline sig
                             yes = "p > 0.05",
                             # if p < 0.05, see if this remains after fdr correction
                             no = ifelse(test = results_dffilt$fdr_p > 0.05,
                                         yes = "p < 0.05",
                                         no = "fdr p < 0.05"))

table(results_dffilt$sig) %>% knitr::kable(caption = "Significance levels for regressions")


volcano_df <- results_dffilt
volcano_df$label <- NA

volcano_df$annotated <- volcano_df$metabolite %>% 
    sapply(function(x) !grepl("^[c][\\d]{2,}", 
                              x, perl=T))
volcano_df$metabolite[volcano_df$annotated==F] <- "unannotated"

# create labels for the volcano plot
volcano_df$intx<- paste(sapply(volcano_df$microbe, 
                               function(x) str_split(x, "f_")[[1]][2]), 
                        ":", 
                        volcano_df$metabolite)

volcano_df$label[
    volcano_df$sig == "fdr p < 0.05"
    ] <- volcano_df$intx[volcano_df$sig == "fdr p < 0.05"]

# If label microbe was NA, make the whole label NA
volcano_df$label[
    volcano_df$label %>% 
    sapply(function(x) grepl("^[NA]", 
                              x, perl=T))] <- NA

p <- ggplot(data=volcano_df, aes(x=beta, y=-log10(p), col=sig, label=label)) + 
    geom_point() + 
    geom_text_repel(size = 2,
                    max.overlaps = 25) +
    scale_color_manual(values=c("red", "blue", "black")) +
    theme(legend.title=element_blank())
p

```

# Tables of significant microbe-metabolite relationships
These are long, but I have them separated into positive correlations and negative correlations (sorted by p value), followed by the most frequent metabolites with significant relationships, then the most frequent annotated metabolites.

```{r sig_tables, echo=F}
sig_intx <- results_dffilt %>% 
    filter(sig == "fdr p < 0.05") 

heatmap_df <- sig_intx %>% 
    select(microbe, metabolite, beta) %>%
    pivot_wider(names_from = metabolite, values_from = beta)

row.names(heatmap_df) <- heatmap_df$microbe
heatmap_df %>% 
    select(-microbe) %>% 
    complete() %>% 
    as.matrix() %>% 
    heatmap(Colv = NA, Rowv = NA, labRow = rownames(heatmap_df))

heatmap_df <- sig_intx
heatmap_df$metabolite <- heatmap_df$metabolite %>%
    sapply(function(x) str_wrap(x, width=10) %>% paste0(sep="\n"))
    

p <- ggplot(heatmap_df, aes(microbe, metabolite, fill= beta)) + 
    geom_tile(colour="black", size=0.2) + 
    scale_x_discrete(labels = scales::label_wrap(10)) +
    coord_fixed(1) +
    theme_minimal()
p

    
sig_intx[order(sig_intx$p),
         c("microbe", "metabolite", "p", "fdr_p", "beta")] %>% 
    filter(beta > 0) %>%
    knitr::kable(caption = "Positively associated microbes and metabolites")


sig_intx[order(sig_intx$p),
         c("microbe", "metabolite", "p", "fdr_p", "beta")] %>% 
    filter(beta < 0) %>%
    knitr::kable(caption = "Negatively associated microbes and metabolites")


table(sig_intx$metabolite)[table(sig_intx$metabolite) %>% 
                               order(decreasing=T)] %>% 
    head(10) %>% 
    knitr::kable(caption = "Metabolites with most frequent significant relationships with microbes",
                 col.names = c("Metabolite", "Frequency"))

sig_intx$annotated <- sig_intx$metabolite %>% 
    sapply(function(x) !grepl("^[c][\\d]{3,}", 
                              x, perl=T))

named_sig_intx <- sig_intx %>% filter(annotated == TRUE)

table(named_sig_intx$metabolite)[table(named_sig_intx$metabolite) %>%
                                     order(decreasing=T)] %>% 
    head(10) %>% 
    knitr::kable(col.names = c("Metabolite", "Frequency"),
                 caption = "Annotated metabolites with most frequent significant relationships with microbes")


# microbes
table(sig_intx$microbe)[table(sig_intx$microbe) %>% 
                               order(decreasing=T)] %>% 
    head(10) %>% 
    knitr::kable(caption = "Microbes with most frequent significant relationships with microbes",
                 col.names = c("Microbe", "Frequency"))
```




# Mixed effects modeling
Adding a random effect for humanized microbiome ID for a formula of metabolite ~ microbe + (1|humanized_id)


```{r run_lmes}
lme_df <- all_df %>% janitor::clean_names()
lme_df$PID <- metadata$PID

# Janet Seibert's suggested dffits threshold
dffits_thresh <- 4

# create function to parallelize
run_lme <- function(i, j){
    microbe <- feat_name_mapped[feat_name_mapped$old==genus_names[i], 
                                "new"]
    metabolite <- feat_name_mapped[feat_name_mapped$old==names(metabo_df)[j], 
                                   "new"]
    # scale the metabolite so beta is interpretable
    curr_lm_df <- lme_df[, c(microbe, metabolite, "PID")]
    curr_lm_df[, metabolite] <- scale(curr_lm_df[, metabolite])
    
    # create formula
    formula <- paste0(metabolite, " ~ ", microbe, " + (1|PID)")
    
    # run model
    mod <- lmerTest::lmer(formula, curr_lm_df)
    
    # extract p and beta
    p <- coef(summary(mod))[microbe,"Pr(>|t|)"]
    my_beta <- coef(summary(mod))[microbe,"Estimate"]
    
    # calculate maximum influence of any point
    dffits_df <- as.data.frame(HLMdiag::mdffits(mod))
    max_influence <- max(abs(dffits_df))
    
    # add new results to df
    new_results <- list(microbe, metabolite, p, my_beta, max_influence)
    return(new_results)
}

#setup parallel backend to use many processors
cores <- detectCores()
cl <- makeCluster(cores[1]-1) #not to overload your computer
doParallel::registerDoParallel(cl)

registerDoSNOW(cl) # not sure what this is
iterations_i <- ncol(genus)
iterations_j <- ncol(metabo_df)
pb <- txtProgressBar(max = iterations_i*iterations_j, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)


results_lme <- data.frame(matrix(nrow=ncol(genus)*ncol(metabo_df), 
                                      ncol=5))
names(results_lme) <- c("microbe", "metabolite", "p", "beta", "max_influence") 

ptm <- proc.time()
y_lme <- foreach(i=1:iterations_i, 
             .combine=cbind, 
             .options.snow = opts) %:%
    foreach(j=1:iterations_j, 
            .combine=cbind, 
            .options.snow = opts) %dopar% {
                progress(i)
                run_lme(i,j)
            }

print(paste0((proc.time() - ptm)[["elapsed"]]/60, " minutes"))

#stop cluster
stopCluster(cl)

results_lme$microbe <- unlist(y_lme[1,])
results_lme$metabolite <- unlist(y_lme[2,])
results_lme$p <- unlist(y_lme[3,])
results_lme$beta <- unlist(y_lme[4,])
results_lme$max_influence <- unlist(y_lme[5,])

write.csv(results_lme, "/Users/johnsterrett/Research-Projects/Reisdorph/GT-micro-metabo/analysis/microbe_metabolite_lme_results.csv")

```


```{r process_and_summarize_lme_results, echo=F}

hist(results_lme$beta, breaks=100)

hist(results_lme$max_influence, breaks=20)

quantile(results_lme$max_influence, c(0.5, 0.9, 0.95, 0.99), na.rm=T)

summary(results_lme)

```